2007-09-04  Andrew Haley  <aph@redhat.com>

	* decl.c (java_init_decl_processing): Call "__cxa_end_cleanup"
	when using the ARM EABI.

2007-08-29  Andrew Haley  <aph@redhat.com>

        * config/arm/libgcc-bpabi.ver: Add _Unwind_Backtrace as GCC_4.3.0.

2007-08-08  Andrew Haley  <aph@redhat.com>

	* config/arm/libunwind.S (UNWIND_WRAPPER _Unwind_Backtrace): New.
	* config/arm/unwind-arm.h (__gnu_Unwind_Backtrace): New.
	* config/arm/unwind-arm.c (__gnu_Unwind_Backtrace): New.

--- gcc/java/decl.c	(revision 128085)
+++ gcc/java/decl.c	(revision 128088)
@@ -1075,7 +1075,10 @@ java_init_decl_processing (void)
   eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS
                                              ? "__gcj_personality_sj0"
                                              : "__gcj_personality_v0");
-  default_init_unwind_resume_libfunc ();
+  if (targetm.arm_eabi_unwinder)
+    unwind_resume_libfunc = init_one_libfunc ("__cxa_end_cleanup");
+  else
+    default_init_unwind_resume_libfunc ();
 
   lang_eh_runtime_type = do_nothing;
 
--- gcc/config/arm/libunwind.S	(revision 128085)
+++ gcc/config/arm/libunwind.S	(revision 128088)
@@ -237,5 +237,6 @@ UNWIND_WRAPPER _Unwind_RaiseException 1
 UNWIND_WRAPPER _Unwind_Resume 1
 UNWIND_WRAPPER _Unwind_Resume_or_Rethrow 1
 UNWIND_WRAPPER _Unwind_ForcedUnwind 3
+UNWIND_WRAPPER _Unwind_Backtrace 2
 
-#endif  /* __symbian__ */
+#endif  /* ndef __symbian__ */
--- gcc/config/arm/libgcc-bpabi.ver	(revision 128085)
+++ gcc/config/arm/libgcc-bpabi.ver	(revision 128088)
@@ -81,3 +81,11 @@ GCC_3.5 {
   # GNU-specific entry point.
   __gnu_unwind_frame
 }
+
+%exclude {
+  _Unwind_Backtrace
+}
+%inherit GCC_4.3.0 GCC_4.2.0
+GCC_4.3.0 {
+  _Unwind_Backtrace
+}
--- gcc/config/arm/unwind-arm.c	(revision 128085)
+++ gcc/config/arm/unwind-arm.c	(revision 128088)
@@ -950,6 +950,66 @@ _Unwind_DeleteException (_Unwind_Excepti
 }
 
 
+/* Perform stack backtrace through unwind data.  */
+_Unwind_Reason_Code
+__gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,
+		       phase2_vrs * entry_vrs);
+_Unwind_Reason_Code
+__gnu_Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument,
+		       phase2_vrs * entry_vrs)
+{
+  phase1_vrs saved_vrs;
+  _Unwind_Reason_Code code;
+
+  _Unwind_Control_Block ucb;
+  _Unwind_Control_Block *ucbp = &ucb;
+
+  /* Set the pc to the call site.  */
+  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];
+
+  /* Save the core registers.  */
+  saved_vrs.core = entry_vrs->core;
+  /* Set demand-save flags.  */
+  saved_vrs.demand_save_flags = ~(_uw) 0;
+  
+  do
+    {
+      /* Find the entry for this routine.  */
+      if (get_eit_entry (ucbp, saved_vrs.core.r[R_PC]) != _URC_OK)
+	{
+	  code = _URC_FAILURE;
+	  break;
+	}
+
+      /* The dwarf unwinder assumes the context structure holds things
+	 like the function and LSDA pointers.  The ARM implementation
+	 caches these in the exception header (UCB).  To avoid
+	 rewriting everything we make the virtual IP register point at
+	 the UCB.  */
+      _Unwind_SetGR((_Unwind_Context *)&saved_vrs, 12, (_Unwind_Ptr) ucbp);
+
+      /* Call trace function.  */
+      if ((*trace) ((_Unwind_Context *) &saved_vrs, trace_argument) 
+	  != _URC_NO_REASON)
+	{
+	  code = _URC_FAILURE;
+	  break;
+	}
+
+      /* Call the pr to decide what to do.  */
+      code = ((personality_routine) UCB_PR_ADDR (ucbp))
+	(_US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND, 
+	 ucbp, (void *) &saved_vrs);
+    }
+  while (code != _URC_END_OF_STACK
+	 && code != _URC_FAILURE);
+
+ finish:
+  restore_non_core_regs (&saved_vrs);
+  return code;
+}
+
+
 /* Common implementation for ARM ABI defined personality routines.
    ID is the index of the personality routine, other arguments are as defined
    by __aeabi_unwind_cpp_pr{0,1,2}.  */
--- gcc/config/arm/unwind-arm.h	(revision 128085)
+++ gcc/config/arm/unwind-arm.h	(revision 128088)
@@ -205,6 +205,13 @@ extern "C" {
 	_Unwind_Control_Block *, struct _Unwind_Context *, void *);
   _Unwind_Reason_Code _Unwind_ForcedUnwind (_Unwind_Control_Block *,
 					    _Unwind_Stop_Fn, void *);
+  /* @@@ Use unwind data to perform a stack backtrace.  The trace callback
+     is called for every stack frame in the call chain, but no cleanup
+     actions are performed.  */
+  typedef _Unwind_Reason_Code (*_Unwind_Trace_Fn) (_Unwind_Context *, void *);
+  _Unwind_Reason_Code _Unwind_Backtrace(_Unwind_Trace_Fn,
+					void*);
+
   _Unwind_Word _Unwind_GetCFA (struct _Unwind_Context *);
   void _Unwind_Complete(_Unwind_Control_Block *ucbp);
   void _Unwind_DeleteException (_Unwind_Exception *);
