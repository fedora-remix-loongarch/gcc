2007-08-29  Jakub Jelinek  <jakub@redhat.com>

	* config/rs6000/rs6000.c (rs6000_emit_sync): For QI or HI mode
	used_m, even if it is 32-bit aligned, adjust used_m MEM to have
	SImode and update m.  Don't run gen_lowpart_common on arbitrary
	memory address, force it to register first.

	* gcc.dg/sync-2.c (AI_ALIGN): Define if not defined.
	(AI): Add AI_ALIGN.
	* gcc.dg/sync-3.c: New test.

--- gcc/config/rs6000/rs6000.c.jj	2007-08-27 14:56:36.000000000 +0200
+++ gcc/config/rs6000/rs6000.c	2007-08-29 22:15:41.000000000 +0200
@@ -12757,14 +12757,16 @@ rs6000_emit_sync (enum rtx_code code, en
 	    ishift = GET_MODE_BITSIZE (SImode) - GET_MODE_BITSIZE (mode);
 
 	  shift = GEN_INT (ishift);
+	  used_m = change_address (used_m, SImode, 0);
 	}
       else
 	{
 	  rtx addrSI, aligned_addr;
 	  int shift_mask = mode == QImode ? 0x18 : 0x10;
 
-	  addrSI = force_reg (SImode, gen_lowpart_common (SImode,
-							  XEXP (used_m, 0)));
+	  addrSI = gen_lowpart_common (SImode,
+				       force_reg (Pmode, XEXP (used_m, 0)));
+	  addrSI = force_reg (SImode, addrSI);
 	  shift = gen_reg_rtx (SImode);
 
 	  emit_insn (gen_rlwinm (shift, addrSI, GEN_INT (3),
@@ -12777,14 +12779,14 @@ rs6000_emit_sync (enum rtx_code code, en
 				       1, OPTAB_LIB_WIDEN);
 	  used_m = change_address (used_m, SImode, aligned_addr);
 	  set_mem_align (used_m, 32);
-	  /* It's safe to keep the old alias set of USED_M, because
-	     the operation is atomic and only affects the original
-	     USED_M.  */
-	  if (GET_CODE (m) == NOT)
-	    m = gen_rtx_NOT (SImode, used_m);
-	  else
-	    m = used_m;
 	}
+      /* It's safe to keep the old alias set of USED_M, because
+	 the operation is atomic and only affects the original
+	 USED_M.  */
+      if (GET_CODE (m) == NOT)
+	m = gen_rtx_NOT (SImode, used_m);
+      else
+	m = used_m;
 
       if (GET_CODE (op) == NOT)
 	{
--- gcc/testsuite/gcc.dg/sync-2.c.jj	2006-10-05 00:25:32.000000000 +0200
+++ gcc/testsuite/gcc.dg/sync-2.c	2007-08-29 21:49:47.000000000 +0200
@@ -8,7 +8,11 @@
 extern void abort (void);
 extern void *memcpy (void *, const void *, __SIZE_TYPE__);
 
-static char AI[18];
+#ifndef AI_ALIGN
+#define AI_ALIGN
+#endif
+
+static char AI[18] AI_ALIGN;
 static char init_qi[18] = { 3,5,7,9,0,0,0,0,-1,0,0,0,0,0,-1,0,0,0 };
 static char test_qi[18] = { 3,5,7,9,1,4,22,-12,7,8,9,7,1,-12,7,8,9,7 };
 
--- gcc/testsuite/gcc.dg/sync-3.c.jj	2007-08-29 21:49:59.000000000 +0200
+++ gcc/testsuite/gcc.dg/sync-3.c	2007-08-29 22:00:31.000000000 +0200
@@ -0,0 +1,10 @@
+/* { dg-do run } */
+/* { dg-require-effective-target sync_char_short } */
+/* { dg-options "-O2" } */
+/* { dg-options "-march=i486 -O2" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */
+/* { dg-options "-mcpu=v9 -O2" { target sparc*-*-* } } */
+
+/* Test functionality of the intrinsics for 'short' and 'char'.  */
+
+#define AI_ALIGN __attribute__((__aligned__ (4)))
+#include "sync-2.c"
