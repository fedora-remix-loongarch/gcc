2007-11-05  Jakub Jelinek  <jakub@redhat.com>

	PR c++/33836
	* parser.c (cp_parser_unary_expression): For &&label call
	cp_parser_non_integral_constant_expression and return error_mark_node
	if it returned true.

	* g++.dg/ext/label10.C: New test.

--- gcc/cp/parser.c	(revision 129895)
+++ gcc/cp/parser.c	(revision 129896)
@@ -5329,13 +5329,18 @@ cp_parser_unary_expression (cp_parser *p
 	       && token->type == CPP_AND_AND)
 	{
 	  tree identifier;
+	  tree expression;
 
 	  /* Consume the '&&' token.  */
 	  cp_lexer_consume_token (parser->lexer);
 	  /* Look for the identifier.  */
 	  identifier = cp_parser_identifier (parser);
 	  /* Create an expression representing the address.  */
-	  return finish_label_address_expr (identifier);
+	  expression = finish_label_address_expr (identifier);
+	  if (cp_parser_non_integral_constant_expression (parser,
+						"the address of a label"))
+	    expression = error_mark_node;
+	  return expression;
 	}
     }
   if (unary_operator != ERROR_MARK)
--- gcc/testsuite/g++.dg/ext/label10.C	(revision 0)
+++ gcc/testsuite/g++.dg/ext/label10.C	(revision 129896)
@@ -0,0 +1,17 @@
+// PR c++/33836
+// { dg-do compile }
+// { dg-options "-std=gnu++98" }
+
+template<int N> struct A
+{
+  enum { M = && N };	// { dg-error "referenced outside|cannot appear in" }
+};
+
+A<0> a;
+
+void foo ()
+{
+  __label__ P;
+  enum { O = && P };	// { dg-error "cannot appear in" }
+  P:;
+}
