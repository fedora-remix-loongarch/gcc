2017-09-15  Jakub Jelinek  <jakub@redhat.com>

	Backported from mainline
	2017-09-12  Jakub Jelinek  <jakub@redhat.com>

	PR target/82112
	* c-common.c (sync_resolve_size): Instead of c_dialect_cxx ()
	assertion check that in the condition.
	(get_atomic_generic_size): Likewise.  Before testing if parameter
	has pointer type, if it has array type, call for C++
	default_conversion to perform array-to-pointer conversion.

	* c-c++-common/pr82112.c: New test.
	* gcc.dg/pr82112.c: New test.

--- gcc/c-family/c-common.c	(revision 252002)
+++ gcc/c-family/c-common.c	(revision 252003)
@@ -6478,10 +6478,9 @@ sync_resolve_size (tree function, vec<tr
     }
 
   argtype = type = TREE_TYPE ((*params)[0]);
-  if (TREE_CODE (type) == ARRAY_TYPE)
+  if (TREE_CODE (type) == ARRAY_TYPE && c_dialect_cxx ())
     {
       /* Force array-to-pointer decay for C++.  */
-      gcc_assert (c_dialect_cxx());
       (*params)[0] = default_conversion ((*params)[0]);
       type = TREE_TYPE ((*params)[0]);
     }
@@ -6646,10 +6645,9 @@ get_atomic_generic_size (location_t loc,
 
   /* Get type of first parameter, and determine its size.  */
   type_0 = TREE_TYPE ((*params)[0]);
-  if (TREE_CODE (type_0) == ARRAY_TYPE)
+  if (TREE_CODE (type_0) == ARRAY_TYPE && c_dialect_cxx ())
     {
       /* Force array-to-pointer decay for C++.  */
-      gcc_assert (c_dialect_cxx());
       (*params)[0] = default_conversion ((*params)[0]);
       type_0 = TREE_TYPE ((*params)[0]);
     }
@@ -6688,6 +6686,12 @@ get_atomic_generic_size (location_t loc,
       /* __atomic_compare_exchange has a bool in the 4th position, skip it.  */
       if (n_param == 6 && x == 3)
         continue;
+      if (TREE_CODE (type) == ARRAY_TYPE && c_dialect_cxx ())
+	{
+	  /* Force array-to-pointer decay for C++.  */
+	  (*params)[x] = default_conversion ((*params)[x]);
+	  type = TREE_TYPE ((*params)[x]);
+	}
       if (!POINTER_TYPE_P (type))
 	{
 	  error_at (loc, "argument %d of %qE must be a pointer type", x + 1,
--- gcc/testsuite/gcc.dg/pr82112.c	(nonexistent)
+++ gcc/testsuite/gcc.dg/pr82112.c	(revision 252003)
@@ -0,0 +1,21 @@
+/* PR target/82112 */
+/* { dg-do compile } */
+/* { dg-options "-std=gnu90" } */
+
+struct S { int a[10]; } bar (void);
+int b, c;
+
+void
+foo (void)
+{
+  __atomic_load (bar ().a, &b, __ATOMIC_ACQUIRE);	/* { dg-error "argument 1 of .__atomic_load. must be a non-void pointer type" } */
+  __atomic_load (&b, bar ().a, __ATOMIC_ACQUIRE);	/* { dg-error "argument 2 of .__atomic_load. must be a pointer type" } */
+  __atomic_store (bar ().a, &b, __ATOMIC_SEQ_CST);	/* { dg-error "argument 1 of .__atomic_store. must be a non-void pointer type" } */
+  __atomic_store (&b, bar ().a, __ATOMIC_SEQ_CST);	/* { dg-error "argument 2 of .__atomic_store. must be a pointer type" } */
+  __atomic_exchange (bar ().a, &b, &c, __ATOMIC_RELAXED);	/* { dg-error "argument 1 of .__atomic_exchange. must be a non-void pointer type" } */
+  __atomic_exchange (&b, bar ().a, &c, __ATOMIC_RELAXED);	/* { dg-error "argument 2 of .__atomic_exchange. must be a pointer type" } */
+  __atomic_exchange (&b, &c, bar ().a, __ATOMIC_RELAXED);	/* { dg-error "argument 3 of .__atomic_exchange. must be a pointer type" } */
+  __atomic_compare_exchange (bar ().a, &b, &c, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);	/* { dg-error "argument 1 of .__atomic_compare_exchange. must be a non-void pointer type" } */
+  __atomic_compare_exchange (&b, bar ().a, &c, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);	/* { dg-error "argument 2 of .__atomic_compare_exchange. must be a pointer type" } */
+  __atomic_compare_exchange (&b, &c, bar ().a, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);	/* { dg-error "argument 3 of .__atomic_compare_exchange. must be a pointer type" } */
+}
--- gcc/testsuite/c-c++-common/pr82112.c	(nonexistent)
+++ gcc/testsuite/c-c++-common/pr82112.c	(revision 252003)
@@ -0,0 +1,13 @@
+/* PR target/82112 */
+/* { dg-do compile } */
+
+int c[10], d[10], e[10], f[10], g[10], h[10], i[10], j[10], k[10], l[10];
+
+void
+foo (void)
+{
+  __atomic_load (c, d, __ATOMIC_ACQUIRE);
+  __atomic_store (e, f, __ATOMIC_SEQ_CST);
+  __atomic_exchange (g, h, i, __ATOMIC_RELAXED);
+  __atomic_compare_exchange (j, k, l, 1, __ATOMIC_RELAXED, __ATOMIC_RELAXED);
+}
