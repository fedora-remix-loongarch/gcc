2007-12-09  Jakub Jelinek  <jakub@redhat.com>

	PR c++/34178
	PR c++/34340
	* repo.c (repo_emit_p): Return 2 for DECL_INTEGRAL_CONSTANT_VAR_P
	in class scope rather than DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P.
	Return 2 also if DECL_EXPLICIT_INSTANTIATION.
	* decl2.c (import_export_decl): Don't make VAR_DECLs import_p when
	flag_use_repository and repo_emit_p returned 2.

	* g++.dg/template/repo6.C: New test.
	* g++.dg/template/repo7.C: New test.
	* g++.dg/template/repo8.C: New test.

--- gcc/cp/decl2.c	(revision 130726)
+++ gcc/cp/decl2.c	(revision 130727)
@@ -2230,7 +2230,8 @@ import_export_decl (tree decl)
     {
       /* DECL is an implicit instantiation of a function or static
 	 data member.  */
-      if (flag_implicit_templates
+      if ((flag_implicit_templates
+	   && !flag_use_repository)
 	  || (flag_implicit_inline_templates
 	      && TREE_CODE (decl) == FUNCTION_DECL
 	      && DECL_DECLARED_INLINE_P (decl)))
--- gcc/cp/repo.c	(revision 130726)
+++ gcc/cp/repo.c	(revision 130727)
@@ -304,16 +304,19 @@ repo_emit_p (tree decl)
 	  && (!TYPE_LANG_SPECIFIC (type)
 	      || !CLASSTYPE_TEMPLATE_INSTANTIATION (type)))
 	return 2;
-      /* Static data members initialized by constant expressions must
+      /* Const static data members initialized by constant expressions must
 	 be processed where needed so that their definitions are
 	 available.  */
-      if (DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)
+      if (DECL_INTEGRAL_CONSTANT_VAR_P (decl)
 	  && DECL_CLASS_SCOPE_P (decl))
 	return 2;
     }
   else if (!DECL_TEMPLATE_INSTANTIATION (decl))
     return 2;
 
+  if (DECL_EXPLICIT_INSTANTIATION (decl))
+    return 2;
+
   /* For constructors and destructors, the repository contains
      information about the clones -- not the original function --
      because only the clones are emitted in the object file.  */
--- gcc/testsuite/g++.dg/template/repo7.C	(revision 0)
+++ gcc/testsuite/g++.dg/template/repo7.C	(revision 130727)
@@ -0,0 +1,23 @@
+// PR c++/34340
+// { dg-options "-frepo" }
+// { dg-final { cleanup-repo-files } }
+
+struct A
+{
+  int a;
+};
+
+template <typename T> struct D
+{
+  static const A b;
+};
+
+template<typename T> const A D<T>::b = { 2 };
+template class D<A>;
+
+const A *x = &D<A>::b;
+
+int
+main ()
+{
+}
--- gcc/testsuite/g++.dg/template/repo8.C	(revision 0)
+++ gcc/testsuite/g++.dg/template/repo8.C	(revision 130727)
@@ -0,0 +1,22 @@
+// PR c++/34340
+// { dg-options "-frepo" }
+// { dg-final { cleanup-repo-files } }
+
+struct A
+{
+  int a;
+};
+
+template <typename T> struct D
+{
+  static const A b;
+};
+
+template<typename T> const A D<T>::b = { 2 };
+
+const A *x = &D<A>::b;
+
+int
+main ()
+{
+}
--- gcc/testsuite/g++.dg/template/repo6.C	(revision 0)
+++ gcc/testsuite/g++.dg/template/repo6.C	(revision 130727)
@@ -0,0 +1,24 @@
+// PR c++/34178
+// { dg-options "-frepo" }
+// { dg-final { cleanup-repo-files } }
+
+template<typename T>
+class A
+{
+private:
+  static const int x;
+  static int y;
+
+public:
+  int getX () { return x + y; }
+};
+
+template<typename T> const int A<T>::x = 0;
+template<typename T> int A<T>::y = 0;
+
+int
+main ()
+{
+  A<int> a;
+  return a.getX();
+}
