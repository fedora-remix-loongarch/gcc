2007-11-02  Jakub Jelinek  <jakub@redhat.com>

	PR c++/33516
	* parser.c (cp_parser_nested_name_specifier_opt): Use
	TYPE_MAIN_VARIANT (new_scope) as scope if new_scope is an incomplete
	typedef of currently open class.

	* g++.dg/lookup/typedef1.C: New test.

--- gcc/cp/parser.c	(revision 129861)
+++ gcc/cp/parser.c	(revision 129862)
@@ -4085,7 +4085,15 @@ cp_parser_nested_name_specifier_opt (cp_
 	  && !COMPLETE_TYPE_P (new_scope)
 	  /* Do not try to complete dependent types.  */
 	  && !dependent_type_p (new_scope))
-	new_scope = complete_type (new_scope);
+	{
+	  new_scope = complete_type (new_scope);
+	  /* If it is a typedef to current class, use the current
+	     class instead, as the typedef won't have any names inside
+	     it yet.  */
+	  if (!COMPLETE_TYPE_P (new_scope)
+	      && currently_open_class (new_scope))
+	    new_scope = TYPE_MAIN_VARIANT (new_scope);
+	}
       /* Make sure we look in the right scope the next time through
 	 the loop.  */
       parser->scope = new_scope;
--- gcc/testsuite/g++.dg/lookup/typedef1.C	(revision 0)
+++ gcc/testsuite/g++.dg/lookup/typedef1.C	(revision 129862)
@@ -0,0 +1,32 @@
+// PR c++/33516
+// { dg-do compile }
+
+struct S1;
+typedef S1 T1;
+struct S1 {
+  typedef int U;
+  T1::U i;
+};
+struct S2;
+typedef S2 T2;
+struct S2 {
+  typedef int U;
+};
+T2::U j;
+struct S3;
+typedef S3 T3;
+struct S3 {
+  typedef int U;
+  S3::U i;
+};
+
+void
+foo ()
+{
+  S1 s1;
+  S2 s2;
+  S3 s3;
+  s1.i = 6;
+  j = 7;
+  s3.i = 8;
+}
